# This workflow runs and tests all Marimo notebooks in the project
# It creates a matrix of jobs, one for each notebook, and runs them in parallel
name: "Marimo"

on:
  push

jobs:
  # Parse .env file and build a matrix of notebooks to test
  parse-env:
    runs-on: ubuntu-latest
    outputs:
      marimo-folder: ${{ steps.export.outputs.MARIMO_FOLDER }}
      notebook-list: ${{ steps.notebooks.outputs.matrix }}
    steps:
      # Check out the repository code
      - uses: actions/checkout@v4

      # Read environment variables from .env file if it exists
      - name: Parse .env and export variables
        id: export
        run: |
          set -a
          if [ -f .env ]; then
            source .env
          else
            echo "WARNING: .env file not found"
          fi
          echo "MARIMO_FOLDER=${MARIMO_FOLDER:-book/marimo}" >> "$GITHUB_OUTPUT"
          set +a
        shell: bash

      # Find all Python files in the marimo folder and create a matrix for parallel execution
      - name: Find notebooks and build matrix
        id: notebooks
        run: |
          NOTEBOOK_DIR="${{ steps.export.outputs.MARIMO_FOLDER }}"
          echo "Searching notebooks in: $NOTEBOOK_DIR"
          notebooks=$(find "$NOTEBOOK_DIR" -name "*.py" -print0 | xargs -0 -n1 echo | jq -R -s -c 'split("\n")[:-1]')
          echo "matrix=$notebooks" >> "$GITHUB_OUTPUT"
        shell: bash

  # Create one job per notebook using the matrix strategy for parallel execution
  test-notebooks:
    runs-on: ubuntu-latest
    needs: parse-env
    strategy:
      matrix:
        notebook: ${{ fromJson(needs.parse-env.outputs.notebook-list) }}
    name: Run notebook ${{ matrix.notebook }}
    steps:
      # Check out the repository code
      - uses: actions/checkout@v4

      # Set up Python environment with the specified version
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      # Install the uv package manager for Python dependencies
      - name: Install uv
        run: |
          make install
        shell: bash

      # Execute the notebook with the appropriate runner based on its content
      - name: Run notebook
        run: |
          NOTEBOOK="${{ matrix.notebook }}"
          echo "Running $NOTEBOOK"
          
          # Check if the notebook contains a SCRIPT section with dependencies
          # If it does, use uv run to handle dependencies automatically
          # Otherwise, use standard python interpreter
          if grep -q "# /// script" "$NOTEBOOK"; then
            echo "SCRIPT section found, using uv run"
            uv run "$NOTEBOOK"
          else
            echo "No SCRIPT section found, using python"
            python "$NOTEBOOK"
          fi
        shell: bash
